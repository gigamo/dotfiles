#!/bin/zsh

# reload zshrc
function src() {
  autoload -U zrecompile
  [[ -f ~/.zshrc ]] && zrecompile -p ~/.zshrc
  for i in "$(find ~/.zsh/ -type f)"; do
    [[ -f $i ]] && zrecompile -p $i
    [[ -f $i.zwc.old ]] && rm -f $i.zwc.old
  done
  [[ -f ~/.zcompdump ]] && zrecompile -p ~/.zcompdump
  [[ -f ~/.zcompdump ]] && zrecompile -p ~/.zcompdump
  [[ -f ~/.zshrc.zwc.old ]] && rm -f ~/.zshrc.zwc.old
  [[ -f ~/.zcompdump.zwc.old ]] && rm -f ~/.zcompdump.zwc.old
  source ~/.zshrc
}

function add_alias() {
  local name=$1 value="$2"
  echo "alias $name='$value'" >> ~/.zsh/alias
  eval "alias $name='$value'"
  alias $name
}

# git functions
function ga()  { git add $* }
function gl()  { git log $* }
function gs()  { git status -sb $* }
function gp()  { git push $* }
function gc()  { git commit -m "$*" }
function gpl() { git pull $* }
function gco() {
  if [ -z "$1" ]; then
    git checkout master
  else
    git checkout $*
  fi
}

function mkmine() { sudo chown -R ${USER} ${1:-.}; }

# Usage: sanitize <file>
function sanitize() {
  chmod -R u=rwX,go=rX "$@"
  chown -R ${USER}.users "$@"
}

# roll archive.tar.gz dir/**/*
function roll() {
  local FILE
  FILE=$1
  case $FILE in
    *.tar.bz2)  shift && tar cjf $FILE $* ;;
    *.tbz2)     shift && tar cjf $FILE $* ;;
    *.tar.gz)   shift && tar czf $FILE $* ;;
    *.tgz)      shift && tar czf $FILE $* ;;
    *.tar.xz)   shift && tar cJf $FILE $* ;;
    *.zip)      shift && zip $FILE $*     ;;
    *.rar)      shift && rar $FILE $*     ;;
  esac
}

function extract_archive() {
  local old_dirs current_dirs lower
  lower=${(L)1}
  old_dirs=( *(N/) )
  case $lower in
    *.tar.bz2)  tar xvjf $1   ;;
    *.tar.gz)   tar xvzf $1   ;;
    *.tar.xz)   tar xvJf $1   ;;
    *.bz2)      bunzip2 $1    ;;
    *.rar)      unrar x $1    ;;
    *.gz)       gunzip $1     ;;
    *.tar)      tar xvf $1    ;;
    *.tbz2)     tar xvjf $1   ;;
    *.tgz)      tar xvzf $1   ;;
    *.zip)      unzip $1      ;;
    *.Z)        uncompress $1 ;;
    *.7z)       7z x $1       ;;
    *.xz)       unxz $1       ;;
    *.exe)      cabextract $1 ;;
    *.lha)      lha e $1      ;;
    *) echo "Unknown archive type: $1" ||Â return 1 ;;
  esac
  # Change in to the newly created directory, and
  # list the directory contents, if there is one.
  current_dirs=( *(N/) )
  for i in {1..${#current_dirs}}; do
    if [[ $current_dirs[$i] != $old_dirs[$i] ]]; then
      cd $current_dirs[$i]
      break
    fi
  done
}

function cd() {
  builtin cd "$@"
  ll
}

# marks
export MARKPATH=$HOME/.marks

function jump() {
  builtin cd -P $MARKPATH/$1 2>/dev/null || echo "No such mark: $1"
}

function mark() {
  mkdir -p $MARKPATH; ln -s "$(pwd)" $MARKPATH/$1
}

function unmark() {
  rm -i $MARKPATH/$1
}

function marks() {
  ls -l $MARKPATH | sed 's/  / /g' | cut -d' ' -f9- | sed 's/@//g' && echo
}

function conf() {
  case $1 in
    i3)         vim ~/.config/i3/config      ;;
    termite)    vim ~/.config/termite/config ;;
    awesome)    vim ~/.config/awesome/rc.lua ;;
    zsh)        vim ~/.zshrc                 ;;
    xinit)      vim ~/.xinitrc               ;;
    xresources) vim ~/.Xresources            ;;
    xdefaults)  vim ~/.Xdefaults             ;;
    irssi)      vim ~/.irssi/config          ;;
    vim)        vim ~/.vimrc                 ;;
    gvim)       vim ~/.gvimrc                ;;
    conky)      vim ~/.conkyrc               ;;
    emacs)      vim ~/.spacemacs             ;;
    rtorrent)   vim ~/.rtorrent.rc           ;;
    dlna)       vim ~/.config/minidlna/minidlna.conf ;;
    *) echo "Unknown app: $1" || return 1    ;;
  esac
}

# replace_in_files Node.root.title Node.root_title
function replace_in_files() {
  local search="$1" replace="$2"
  echo "Replacing ${search} with ${replace}..."
  grep -rl "${search}" | xargs sed -i "s/${search}/${replace}/g"
}

function git_changelog() {
  local v1="$1" v2="$2"
  git log --pretty=format:%s $v1..$v2 . | sort | awk '$0="* "$0'
}

function play() {
  # Skip DASH manifest for speed purposes. This might actually disable
  # being able to specify things like 'bestaudio' as the requested format,
  # but try anyway.
  # Get the best audio that isn't WebM, because afplay doesn't support it.
  # Use "$*" so that quoting the requested song isn't necessary.
  youtube-dl --default-search=ytsearch: \
             --youtube-skip-dash-manifest \
             --output="${TMPDIR:-/tmp/}%(title)s-%(id)s.%(ext)s" \
             --restrict-filenames \
             --format="bestaudio[ext!=webm]" \
             --exec=cvlc "$*"
}

function download_mp3() {
  # Get the best audio, convert it to MP3, and save it to the current
  # directory.
  youtube-dl --default-search=ytsearch: \
             --restrict-filenames \
             --format=bestaudio \
             --extract-audio \
             --audio-format=mp3 \
             --audio-quality=1 "$*"
}

function killsteam() {
  if [[ -f ~/.steampid ]]; then
    local steampid=$(cat ~/.steampid)
    kill -9 $steampid
  else
    echo "Steam is not running."
  fi
}
